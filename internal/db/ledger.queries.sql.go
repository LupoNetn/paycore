// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ledger.queries.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createLedger = `-- name: CreateLedger :one
INSERT INTO ledgers (wallet_id,transaction_id,amount,entry_type,currency,balance_before,balance_after) 
VALUES ($1,$2,$3,$4,$5,$6,$7)
RETURNING id, wallet_id, transaction_id, amount, entry_type, currency, balance_before, balance_after, created_at
`

type CreateLedgerParams struct {
	WalletID      uuid.UUID       `json:"wallet_id"`
	TransactionID uuid.UUID       `json:"transaction_id"`
	Amount        pgtype.Numeric  `json:"amount"`
	EntryType     LedgerEntryType `json:"entry_type"`
	Currency      string          `json:"currency"`
	BalanceBefore pgtype.Numeric  `json:"balance_before"`
	BalanceAfter  pgtype.Numeric  `json:"balance_after"`
}

func (q *Queries) CreateLedger(ctx context.Context, arg CreateLedgerParams) (Ledger, error) {
	row := q.db.QueryRow(ctx, createLedger,
		arg.WalletID,
		arg.TransactionID,
		arg.Amount,
		arg.EntryType,
		arg.Currency,
		arg.BalanceBefore,
		arg.BalanceAfter,
	)
	var i Ledger
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.TransactionID,
		&i.Amount,
		&i.EntryType,
		&i.Currency,
		&i.BalanceBefore,
		&i.BalanceAfter,
		&i.CreatedAt,
	)
	return i, err
}

const getUserBalance = `-- name: GetUserBalance :one
SELECT COALESCE(SUM(
  CASE 
    WHEN entry_type = 'credit' THEN amount
    WHEN entry_type = 'debit' THEN -amount
  END
), 0)
FROM ledgers
WHERE wallet_id = $1
`

func (q *Queries) GetUserBalance(ctx context.Context, walletID uuid.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, getUserBalance, walletID)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}
